strip.text.x = element_text(size = 10),
plot.margin = margin(.2, .3, .1, 0, "cm"),
legend.position = "none",
legend.title = element_blank()) +
#coord_cartesian(xlim = c(50, 200)) +
theme(strip.background = element_rect(fill = "white")) +
facet_wrap(~YEAR, scales = "free_y")
FL_YFT_SYC_FLL = FL_YFT_CWP55[FLEET_CODE == "SYC" & GEAR_CODE == "FLL", .(N = sum(FISH_COUNT)), keyby = .(YEAR, CLASS_LOW, CLASS_HIGH)]
FL_YFT_SYC_FLL[, CLASS_MID := (CLASS_LOW + CLASS_HIGH)/2]
ggplot(FL_YFT_SYC_FLL, aes(x = CLASS_MID, y = N)) +
geom_line(linewidth = 1) +
xlab("Fork length (cm)") + ylab("Samples") +
theme(axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
axis.title.y = element_text(size=10),
strip.text.x = element_text(size = 10),
plot.margin = margin(.2, .3, .1, 0, "cm"),
legend.position = "none",
legend.title = element_blank()) +
#coord_cartesian(xlim = c(50, 200)) +
theme(strip.background = element_rect(fill = "white")) +
facet_wrap(~YEAR, scales = "free_y")
SF_RAW_YFT[FLEET_CODE == "SYC" & MEASURE_TYPE_CODE == "LDF" & GEAR_CODE == "ELL", .N, .(MEASURE_TYPE_CODE)]
# Clears the environment
rm(list = ls())
# To avoid switch to scientific notation
options(scipen = 100)
# Load libraries
source("90_LIBS.R")
source("91_TABLEFORMAT_FUNCTION.R")
source("92_STANDARD_SIZE_DATASET_FORMAT_CONVERTER.R")
source("93_DATABASE_CONNECTIONS.R")
# Define dataset name
DATASET_NAME = "IOTC-2024-WPTT26(AS) - YFT - SF frequencies"
# Source the scripts
source("01_SA_PARAMETERS_YFT.R")
source("02_DATA_EXTRACTION.R")
FL_YFT = copy(SF_STD_YFT)
# Filter resolution
FL_YFT_REGULAR_GRIDS = FL_YFT[AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05")]
names(FL_YFT_REGULAR_GRIDS )
# # Map to Indian Ocean 1x1 grids to filter for grids outside Indian Ocean
IO_1x1_GRID_LIST = query(DB_IOTC_MASTER(), "SELECT DISTINCT CODE, NAME_EN FROM refs_gis.V_IO_GRIDS_01x01;")
#
GRIDS_1x1_NOT_IN_IO = unique(merge(FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01"], IO_1x1_GRID_LIST, by.x = "FISHING_GROUND_CODE", by.y = "CODE", all.x = TRUE)[is.na(NAME_EN), .(FISHING_GROUND_CODE)])[order(FISHING_GROUND_CODE)]
GRIDS_1x1_NOT_IN_IO[, CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Remove these grids from the dataset prior to conversion
FL_YFT_REGULAR_GRIDS = FL_YFT_REGULAR_GRIDS[!FISHING_GROUND_CODE %in% GRIDS_1x1_NOT_IN_IO$FISHING_GROUND_CODE]
# Convert 1x1 to 5x5
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01", CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Keep 5x5 grids
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID05x05", CWP55 := FISHING_GROUND_CODE]
FL_YFT_REGULAR_GRIDS[1]
FL_YFT = copy(SF_STD_YFT)
## Iranian purse seiners ####
# No fishing mode available and huge variability in size histograms
#FL_YFT = FL_YFT[!(FLEET_CODE == "IRN" & FISHERY_GROUP_CODE == "PS")]
# 2- Remove EUREY and EUMYT HATR fisheries: mix of handlines and trolling lines?
#FL_YFT = FL_YFT[!(FLEET_CODE %in% c("EUREU", "EUMYT") & GEAR_CODE == "HATR")]
# SPATIAL RESOLUTION EQUAL OR LESS THAN 5x5 ####
# Filter resolution
FL_YFT_REGULAR_GRIDS = FL_YFT[AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05")]
# # Map to Indian Ocean 1x1 grids to filter for grids outside Indian Ocean
IO_1x1_GRID_LIST = query(DB_IOTC_MASTER(), "SELECT DISTINCT CODE, NAME_EN FROM refs_gis.V_IO_GRIDS_01x01;")
#
GRIDS_1x1_NOT_IN_IO = unique(merge(FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01"], IO_1x1_GRID_LIST, by.x = "FISHING_GROUND_CODE", by.y = "CODE", all.x = TRUE)[is.na(NAME_EN), .(FISHING_GROUND_CODE)])[order(FISHING_GROUND_CODE)]
GRIDS_1x1_NOT_IN_IO[, CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Remove these grids from the dataset prior to conversion
FL_YFT_REGULAR_GRIDS = FL_YFT_REGULAR_GRIDS[!FISHING_GROUND_CODE %in% GRIDS_1x1_NOT_IN_IO$FISHING_GROUND_CODE]
# Convert 1x1 to 5x5
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01", CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Keep 5x5 grids
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID05x05", CWP55 := FISHING_GROUND_CODE]
# Re-aggregate by 5x5 grids
FL_YFT_REGULAR_TO_CWP55 = FL_YFT_REGULAR_GRIDS[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE = CWP55, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
# Extract area codes from dataset
LIST_NON_STANDARD_AREAS = FL_YFT[!AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05"), .(N_SAMPLES = sum(FISH_COUNT)), keyby = .(FISHING_GROUND_CODE, RAISE_CODE)][order(-N_SAMPLES)]
# Potential filter the list on non-standard areas
# Large areas of areas with too small samples (<50)
LIST_AREAS_TO_REMOVE = c("IO_EAST", "IO_NORTHEAST", "IO_NORTHWEST", "IO_SOUTHEAST", "IO_WEST", "IO_SOUTHWEST", "A230120", "A240140", "A240040")
# Summary of data removed
FL_YFT_IRREGULAR_GRIDS_REMOVED = FL_YFT[FISHING_GROUND_CODE %in% LIST_AREAS_TO_REMOVE, .(N_SAMPLES = sum(FISH_COUNT)), keyby = .(FISHING_GROUND_CODE, RAISE_CODE)]
LIST_NON_STANDARD_AREAS_FILTERED = LIST_NON_STANDARD_AREAS[!FISHING_GROUND_CODE %in% LIST_AREAS_TO_REMOVE]
# Extract mapping between irregular areas and 5x5 grids
MAPPING_NON_STANDARD_AREAS_TO_5x5 =
query(
C_MASTER,
paste0("SELECT SOURCE_CODE AS FISHING_GROUND_CODE, TARGET_CODE AS CWP55, SOURCE_REL_INTERSECTION
FROM refs_gis.AREA_INTERSECTIONS
WHERE SOURCE_CODE IN ('", paste(LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE, collapse = "', '"), "')
AND SUBSTRING(TARGET_CODE, 1, 1) = '6';"))
# Add number of 5x5 grids per irregular area
MAPPING_NON_STANDARD_AREAS_TO_5x5[, N_GRIDS := length(unique(CWP55)), keyby = .(FISHING_GROUND_CODE)]
MAPPING_NON_STANDARD_AREAS_TO_5x5[, PROP_GRIDS := 1/N_GRIDS]
# Map size dataset with 5x5 grids
FL_YFT_IRREGULAR_GRIDS = FL_YFT[FISHING_GROUND_CODE %in% LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE]
FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID = merge.data.table(FL_YFT_IRREGULAR_GRIDS, MAPPING_NON_STANDARD_AREAS_TO_5x5, by.x = "FISHING_GROUND_CODE", by.y = "FISHING_GROUND_CODE", all.x = TRUE, allow.cartesian = TRUE)
# Distribute fish according to surface area
#FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, FISH_ALLOCATED := FISH_COUNT * SOURCE_REL_INTERSECTION, by = .(FISHING_GROUND_CODE)][, FISH_COUNT := NULL]
# Distribute fish evenly according to number of grids
FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, FISH_ALLOCATED := FISH_COUNT * PROP_GRIDS, by = .(FISHING_GROUND_CODE)][, FISH_COUNT := NULL]
# Rename FISH COUNT column
setnames(FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID, old = "FISH_ALLOCATED", new = "FISH_COUNT")
# Re-aggregate by 5x5 grids
FL_YFT_IRREGULAR_TO_CWP55 = FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE = CWP55, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
## ORIGINAL AREAS DATASET ####
FL_YFT_ORIGINAL_GRIDS = rbindlist(list(FL_YFT_REGULAR_GRIDS[, -c("CWP55")], FL_YFT_IRREGULAR_GRIDS))
## ORIGINAL GRID DATASET ####
FL_YFT_ORIGINAL_GRIDS = rbindlist(list(FL_YFT_REGULAR_GRIDS[, -c("CWP55")], FL_YFT_IRREGULAR_GRIDS))
## 5x5 GRID DATASET
FL_YFT_GRIDS_TO_CWP55 = rbindlist(list(FL_YFT_REGULAR_TO_CWP55, FL_YFT_IRREGULAR_TO_CWP55))
FL_YFT_ORIGINAL_GRIDS[, .(N = sum(FISH_COUNT)), keyby = .(AREA_TYPE_CODE)]
FL_YFT_GRIDS_TO_CWP55[, .(N = sum(FISH_COUNT)), keyby = .(AREA_TYPE_CODE)]
FL_YFT_GRIDS_TO_CWP55[, .(N = sum(FISH_COUNT)), keyby = .(substring(FISHING_GROUND_CODE, 1, 1))]
## ORIGINAL GRID DATASET ####
FL_YFT_ORIGINAL_GRIDS = rbindlist(list(FL_YFT_REGULAR_GRIDS[, -c("AREA_TYPE_CODE", "CWP55")], FL_YFT_IRREGULAR_GRIDS))
names(FL_YFT_IRREGULAR_GRIDS)
names(FL_YFT_REGULAR_TO_CWP55)
FL_YFT_IRREGULAR_GRIDS[, .N, .(SIZE_BIN)]
names(FL_YFT)
FL_YFT[, .N, .(MEASURE_TYPE_CODE)]
FL_YFT[1:5]
FL_YFT = copy(SF_STD_YFT)[, -c("SEX_CODE", "SIZE_BIN", "WEIGHT")]
# Filter resolution
FL_YFT_REGULAR_GRIDS = FL_YFT[AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05")]
# # Map to Indian Ocean 1x1 grids to filter for grids outside Indian Ocean
IO_1x1_GRID_LIST = query(DB_IOTC_MASTER(), "SELECT DISTINCT CODE, NAME_EN FROM refs_gis.V_IO_GRIDS_01x01;")
#
GRIDS_1x1_NOT_IN_IO = unique(merge(FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01"], IO_1x1_GRID_LIST, by.x = "FISHING_GROUND_CODE", by.y = "CODE", all.x = TRUE)[is.na(NAME_EN), .(FISHING_GROUND_CODE)])[order(FISHING_GROUND_CODE)]
GRIDS_1x1_NOT_IN_IO[, CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Remove these grids from the dataset prior to conversion
FL_YFT_REGULAR_GRIDS = FL_YFT_REGULAR_GRIDS[!FISHING_GROUND_CODE %in% GRIDS_1x1_NOT_IN_IO$FISHING_GROUND_CODE]
# Convert 1x1 to 5x5
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01", CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Keep 5x5 grids
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID05x05", CWP55 := FISHING_GROUND_CODE]
# Re-aggregate by 5x5 grids
FL_YFT_REGULAR_TO_CWP55 = FL_YFT_REGULAR_GRIDS[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE = CWP55, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
FL_YFT_REGULAR_TO_CWP55[, sum(FISH_COUNT)]
FL_YFT_REGULAR_GRIDS[, sum(FISH_COUNT)]
LIST_NON_STANDARD_AREAS = FL_YFT[!AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05"), .(N_SAMPLES = sum(FISH_COUNT)), keyby = .(FISHING_GROUND_CODE, RAISE_CODE)][order(-N_SAMPLES)]
# Potential filter the list on non-standard areas
# Large areas of areas with too small samples (<50)
LIST_AREAS_TO_REMOVE = c("IO_EAST", "IO_NORTHEAST", "IO_NORTHWEST", "IO_SOUTHEAST", "IO_WEST", "IO_SOUTHWEST", "A230120", "A240140", "A240040")
# Summary of data removed
FL_YFT_IRREGULAR_GRIDS_REMOVED = FL_YFT[FISHING_GROUND_CODE %in% LIST_AREAS_TO_REMOVE, .(N_SAMPLES = sum(FISH_COUNT)), keyby = .(FISHING_GROUND_CODE, RAISE_CODE)]
LIST_NON_STANDARD_AREAS_FILTERED = LIST_NON_STANDARD_AREAS[!FISHING_GROUND_CODE %in% LIST_AREAS_TO_REMOVE]
# Extract mapping between irregular areas and 5x5 grids
MAPPING_NON_STANDARD_AREAS_TO_5x5 =
query(
C_MASTER,
paste0("SELECT SOURCE_CODE AS FISHING_GROUND_CODE, TARGET_CODE AS CWP55, SOURCE_REL_INTERSECTION
FROM refs_gis.AREA_INTERSECTIONS
WHERE SOURCE_CODE IN ('", paste(LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE, collapse = "', '"), "')
AND SUBSTRING(TARGET_CODE, 1, 1) = '6';"))
# Add number of 5x5 grids per irregular area
MAPPING_NON_STANDARD_AREAS_TO_5x5[, N_GRIDS := length(unique(CWP55)), keyby = .(FISHING_GROUND_CODE)]
MAPPING_NON_STANDARD_AREAS_TO_5x5[, PROP_GRIDS := 1/N_GRIDS]
# Map size dataset with 5x5 grids
FL_YFT_IRREGULAR_GRIDS = FL_YFT[FISHING_GROUND_CODE %in% LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE]
nameS(FL_YFT_IRREGULAR_GRIDS)
names(FL_YFT_IRREGULAR_GRIDS)
sum(FL_YFT_IRREGULAR_GRIDS$FISH_COUNT)
toto = FL_YFT[FISHING_GROUND_CODE %in% LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE = CWP55, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
toto = FL_YFT[FISHING_GROUND_CODE %in% LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
sum(toto$FISH_COUNT)
# Map size dataset with 5x5 grids
FL_YFT_IRREGULAR_GRIDS = FL_YFT[FISHING_GROUND_CODE %in% LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID = merge.data.table(FL_YFT_IRREGULAR_GRIDS, MAPPING_NON_STANDARD_AREAS_TO_5x5, by.x = "FISHING_GROUND_CODE", by.y = "FISHING_GROUND_CODE", all.x = TRUE, allow.cartesian = TRUE)
# Distribute fish evenly according to number of grids
FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, FISH_ALLOCATED := FISH_COUNT * PROP_GRIDS, by = .(FISHING_GROUND_CODE)][, FISH_COUNT := NULL]
# Rename FISH COUNT column
setnames(FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID, old = "FISH_ALLOCATED", new = "FISH_COUNT")
# Re-aggregate by 5x5 grids
FL_YFT_IRREGULAR_TO_CWP55 = FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE = CWP55, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
sort(unique(names(FL_YFT_REGULAR_GRIDS[, -c("AREA_TYPE_CODE", "CWP55")])))
sort(unique(names(FL_YFT_IRREGULAR_GRIDS)))
## ORIGINAL GRID DATASET ####
FL_YFT_ORIGINAL_GRIDS = rbindlist(list(FL_YFT_REGULAR_GRIDS[, -c("QUARTER", "AREA_TYPE_CODE", "CWP55")], FL_YFT_IRREGULAR_GRIDS))
## ORIGINAL GRID DATASET ####
FL_YFT_ORIGINAL_GRIDS = rbindlist(list(FL_YFT_REGULAR_GRIDS[, -c("QUARTER", "AREA_TYPE_CODE", "CWP55")], FL_YFT_IRREGULAR_GRIDS), use.names = TRUE)
FL_YFT_ORIGINAL_GRIDS[, .(N = sum(FISH_COUNT)), keyby = .(substring(FISHING_GROUND_CODE, 1, 1))]
## 5x5 GRID DATASET
FL_YFT_GRIDS_TO_CWP55 = rbindlist(list(FL_YFT_REGULAR_TO_CWP55, FL_YFT_IRREGULAR_TO_CWP55))
# Aggregate across 5x5 grids
FL_YFT_CWP55 = FL_YFT_ALL_TO_CWP55[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
# Aggregate across 5x5 grids
FL_YFT_GRIDS_TO_CWP55 = FL_YFT_GRIDS_TO_CWP55[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
FL_YFT_GRIDS_TO_CWP55[, .(N = sum(FISH_COUNT)), keyby = .(substring(FISHING_GROUND_CODE, 1, 1))]
sum(FL_YFT_ORIGINAL_GRIDS$FISH_COUNT)
DATASET_NAME
FL_YFT_ORIGINAL_GRIDS
paste0("../outputs/datasets/", DATASET_NAME, " (original).csv")
paste0("../outputs/datasets/", DATASET_NAME, " (cwp55).csv")
getwd()
# Export the datasets
write.csv(FL_YFT_ORIGINAL_GRIDS, paste0("../outputs/datasets/", DATASET_NAME, " (original).csv"), row.names = FALSE)
write.csv(FL_YFT_GRIDS_TO_CWP55, paste0("../outputs/datasets/", DATASET_NAME, " (cwp55).csv"), row.names = FALSE)
FL_YFT_SYC_FLL = FL_YFT_GRIDS_TO_CWP55[FLEET_CODE == "SYC" & GEAR_CODE == "ELL", .(N = sum(FISH_COUNT)), keyby = .(YEAR, CLASS_LOW, CLASS_HIGH)]
FL_YFT_SYC_FLL[, CLASS_MID := (CLASS_LOW + CLASS_HIGH)/2]
ggplot(FL_YFT_SYC_FLL, aes(x = CLASS_MID, y = N)) +
geom_line(linewidth = 1) +
xlab("Fork length (cm)") + ylab("Samples") +
theme(axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
axis.title.y = element_text(size=10),
strip.text.x = element_text(size = 10),
plot.margin = margin(.2, .3, .1, 0, "cm"),
legend.position = "none",
legend.title = element_blank()) +
#coord_cartesian(xlim = c(50, 200)) +
theme(strip.background = element_rect(fill = "white")) +
facet_wrap(~YEAR, scales = "free_y")
FL_YFT_SYC_FLL[, summary(CLASS_MID)]
FL_YFT_SYC_FLL[CLASS_MID>250]
SF_STD_YFT[FLEET_CODE == "SYC" & CLASS_LOW>200, .N, .(YEAR, GEAR_CODE)]
SF_STD_YFT[FLEET_CODE == "SYC" & YEAR == 2009, .(N), .(GEAR_CODE)]
SF_STD_YFT[FLEET_CODE == "SYC" & YEAR == 2009, .N, .(GEAR_CODE)]
SF_RAW_YFT[FLEET_CODE == "SYC" & YEAR==2009 & GEAR_CODE == "ELL"]
SF_RAW_YFT[FLEET_CODE == "SYC" & YEAR==2009 & GEAR_CODE == "ELL", .(N = sum(FISH_COUNT)), keyby = .(MEASURE_TYPE_CODE)]
SF_RAW_YFT[FLEET_CODE == "SYC" & MEASURE_TYPE_CODE == "LDFT" & GEAR_CODE == "ELL"
]
SF_RAW_YFT[MEASURE_TYPE_CODE == "FLUT"]
SF_RAW_YFT[MEASURE_TYPE_CODE == "FLFT"]
unique(SF_RAW_YFT[, .(MEASURE_TYPE_CODE, MEASURE_TYPE)])[order(MEASURE_TYPE_CODE)]
# Clears the environment
rm(list = ls())
# To avoid switch to scientific notation
options(scipen = 100)
# Load libraries
source("90_LIBS.R")
source("91_TABLEFORMAT_FUNCTION.R")
source("92_STANDARD_SIZE_DATASET_FORMAT_CONVERTER.R")
source("93_DATABASE_CONNECTIONS.R")
# Define dataset name
DATASET_NAME = "IOTC-2024-WPTT26(AS) - YFT - SF frequencies"
# Source the scripts
source("01_SA_PARAMETERS_YFT.R")
source("02_DATA_EXTRACTION.R")
source("03_DATA_PROCESS.R")
names(FL_YFT_REGULAR_GRIDS)
FL_YFT = copy(SF_STD_YFT)
## Iranian purse seiners ####
# No fishing mode available and huge variability in size histograms
#FL_YFT = FL_YFT[!(FLEET_CODE == "IRN" & FISHERY_GROUP_CODE == "PS")]
# 2- Remove EUREY and EUMYT HATR fisheries: mix of handlines and trolling lines?
#FL_YFT = FL_YFT[!(FLEET_CODE %in% c("EUREU", "EUMYT") & GEAR_CODE == "HATR")]
# SPATIAL RESOLUTION EQUAL OR LESS THAN 5x5 ####
# Filter resolution
FL_YFT_REGULAR_GRIDS = FL_YFT[AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05")]
# # Map to Indian Ocean 1x1 grids to filter for grids outside Indian Ocean
IO_1x1_GRID_LIST = query(DB_IOTC_MASTER(), "SELECT DISTINCT CODE, NAME_EN FROM refs_gis.V_IO_GRIDS_01x01;")
#
GRIDS_1x1_NOT_IN_IO = unique(merge(FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01"], IO_1x1_GRID_LIST, by.x = "FISHING_GROUND_CODE", by.y = "CODE", all.x = TRUE)[is.na(NAME_EN), .(FISHING_GROUND_CODE)])[order(FISHING_GROUND_CODE)]
GRIDS_1x1_NOT_IN_IO[, CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Remove these grids from the dataset prior to conversion
FL_YFT_REGULAR_GRIDS = FL_YFT_REGULAR_GRIDS[!FISHING_GROUND_CODE %in% GRIDS_1x1_NOT_IN_IO$FISHING_GROUND_CODE, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
sum(FL_YFT_REGULAR_GRIDS$FISH_COUNT)
FL_YFT = copy(SF_STD_YFT)
## Iranian purse seiners ####
# No fishing mode available and huge variability in size histograms
#FL_YFT = FL_YFT[!(FLEET_CODE == "IRN" & FISHERY_GROUP_CODE == "PS")]
# 2- Remove EUREY and EUMYT HATR fisheries: mix of handlines and trolling lines?
#FL_YFT = FL_YFT[!(FLEET_CODE %in% c("EUREU", "EUMYT") & GEAR_CODE == "HATR")]
# SPATIAL RESOLUTION EQUAL OR LESS THAN 5x5 ####
# Filter resolution
FL_YFT_REGULAR_GRIDS = FL_YFT[AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05")]
# # Map to Indian Ocean 1x1 grids to filter for grids outside Indian Ocean
IO_1x1_GRID_LIST = query(DB_IOTC_MASTER(), "SELECT DISTINCT CODE, NAME_EN FROM refs_gis.V_IO_GRIDS_01x01;")
#
GRIDS_1x1_NOT_IN_IO = unique(merge(FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01"], IO_1x1_GRID_LIST, by.x = "FISHING_GROUND_CODE", by.y = "CODE", all.x = TRUE)[is.na(NAME_EN), .(FISHING_GROUND_CODE)])[order(FISHING_GROUND_CODE)]
GRIDS_1x1_NOT_IN_IO[, CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Remove these grids from the dataset prior to conversion
FL_YFT_REGULAR_GRIDS = FL_YFT_REGULAR_GRIDS[!FISHING_GROUND_CODE %in% GRIDS_1x1_NOT_IN_IO$FISHING_GROUND_CODE]
# Create original file for combination with irregular grid dataset
FL_YFT_REGULAR_GRIDS_ORIGINAL = FL_YFT_REGULAR_GRIDS[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)
# Convert 1x1 to 5x5
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01", CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
FL_YFT = copy(SF_STD_YFT)
## Iranian purse seiners ####
# No fishing mode available and huge variability in size histograms
#FL_YFT = FL_YFT[!(FLEET_CODE == "IRN" & FISHERY_GROUP_CODE == "PS")]
# 2- Remove EUREY and EUMYT HATR fisheries: mix of handlines and trolling lines?
#FL_YFT = FL_YFT[!(FLEET_CODE %in% c("EUREU", "EUMYT") & GEAR_CODE == "HATR")]
# SPATIAL RESOLUTION EQUAL OR LESS THAN 5x5 ####
# Filter resolution
FL_YFT_REGULAR_GRIDS = FL_YFT[AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05")]
# # Map to Indian Ocean 1x1 grids to filter for grids outside Indian Ocean
IO_1x1_GRID_LIST = query(DB_IOTC_MASTER(), "SELECT DISTINCT CODE, NAME_EN FROM refs_gis.V_IO_GRIDS_01x01;")
#
GRIDS_1x1_NOT_IN_IO = unique(merge(FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01"], IO_1x1_GRID_LIST, by.x = "FISHING_GROUND_CODE", by.y = "CODE", all.x = TRUE)[is.na(NAME_EN), .(FISHING_GROUND_CODE)])[order(FISHING_GROUND_CODE)]
GRIDS_1x1_NOT_IN_IO[, CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Remove these grids from the dataset prior to conversion
FL_YFT_REGULAR_GRIDS = FL_YFT_REGULAR_GRIDS[!FISHING_GROUND_CODE %in% GRIDS_1x1_NOT_IN_IO$FISHING_GROUND_CODE]
# Create original file for combination with irregular grid dataset
FL_YFT_REGULAR_GRIDS_ORIGINAL = FL_YFT_REGULAR_GRIDS[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
# Convert 1x1 to 5x5
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01", CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Keep 5x5 grids
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID05x05", CWP55 := FISHING_GROUND_CODE]
# Re-aggregate by 5x5 grids
FL_YFT_REGULAR_TO_CWP55 = FL_YFT_REGULAR_GRIDS[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE = CWP55, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
LIST_NON_STANDARD_AREAS = FL_YFT[!AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05"), .(N_SAMPLES = sum(FISH_COUNT)), keyby = .(FISHING_GROUND_CODE, RAISE_CODE)][order(-N_SAMPLES)]
# Potential filter the list on non-standard areas
# Large areas of areas with too small samples (<50)
LIST_AREAS_TO_REMOVE = c("IO_EAST", "IO_NORTHEAST", "IO_NORTHWEST", "IO_SOUTHEAST", "IO_WEST", "IO_SOUTHWEST", "A230120", "A240140", "A240040")
# Summary of data removed
FL_YFT_IRREGULAR_GRIDS_REMOVED = FL_YFT[FISHING_GROUND_CODE %in% LIST_AREAS_TO_REMOVE, .(N_SAMPLES = sum(FISH_COUNT)), keyby = .(FISHING_GROUND_CODE, RAISE_CODE)]
LIST_NON_STANDARD_AREAS_FILTERED = LIST_NON_STANDARD_AREAS[!FISHING_GROUND_CODE %in% LIST_AREAS_TO_REMOVE]
# Extract mapping between irregular areas and 5x5 grids
MAPPING_NON_STANDARD_AREAS_TO_5x5 =
query(
C_MASTER,
paste0("SELECT SOURCE_CODE AS FISHING_GROUND_CODE, TARGET_CODE AS CWP55, SOURCE_REL_INTERSECTION
FROM refs_gis.AREA_INTERSECTIONS
WHERE SOURCE_CODE IN ('", paste(LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE, collapse = "', '"), "')
AND SUBSTRING(TARGET_CODE, 1, 1) = '6';"))
# Add number of 5x5 grids per irregular area
MAPPING_NON_STANDARD_AREAS_TO_5x5[, N_GRIDS := length(unique(CWP55)), keyby = .(FISHING_GROUND_CODE)]
MAPPING_NON_STANDARD_AREAS_TO_5x5[, PROP_GRIDS := 1/N_GRIDS]
# Map size dataset with 5x5 grids
FL_YFT_IRREGULAR_GRIDS = FL_YFT[FISHING_GROUND_CODE %in% LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID = merge.data.table(FL_YFT_IRREGULAR_GRIDS, MAPPING_NON_STANDARD_AREAS_TO_5x5, by.x = "FISHING_GROUND_CODE", by.y = "FISHING_GROUND_CODE", all.x = TRUE, allow.cartesian = TRUE)
# Distribute fish according to surface area
#FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, FISH_ALLOCATED := FISH_COUNT * SOURCE_REL_INTERSECTION, by = .(FISHING_GROUND_CODE)][, FISH_COUNT := NULL]
# Distribute fish evenly according to number of grids
FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, FISH_ALLOCATED := FISH_COUNT * PROP_GRIDS, by = .(FISHING_GROUND_CODE)][, FISH_COUNT := NULL]
# Rename FISH COUNT column
setnames(FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID, old = "FISH_ALLOCATED", new = "FISH_COUNT")
# Re-aggregate by 5x5 grids
FL_YFT_IRREGULAR_TO_CWP55 = FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE = CWP55, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
## ORIGINAL GRID DATASET ####
FL_YFT_ORIGINAL_GRIDS = rbindlist(list(FL_YFT_REGULAR_GRIDS_ORIGINAL, FL_YFT_IRREGULAR_GRIDS), use.names = TRUE)
## 5x5 GRID DATASET
FL_YFT_GRIDS_TO_CWP55 = rbindlist(list(FL_YFT_REGULAR_TO_CWP55, FL_YFT_IRREGULAR_TO_CWP55))
# Aggregate across 5x5 grids
FL_YFT_GRIDS_TO_CWP55 = FL_YFT_GRIDS_TO_CWP55[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
sum(FL_YFT_ORIGINAL_GRIDS$FISH_COUNT)
sum(FL_YFT_GRIDS_TO_CWP55$FISH_COUNT)
FL_YFT_ORIGINAL_GRIDS[, .(N = sum(FISH_COUNT)), keyby = .(substring(FISHING_GROUND_CODE, 1, 1))]
FL_YFT_GRIDS_TO_CWP55[, .(N = sum(FISH_COUNT)), keyby = .(substring(FISHING_GROUND_CODE, 1, 1))]
# FILTER THE DATASET ####
FL_YFT = copy(SF_STD_YFT)
## Iranian purse seiners ####
# No fishing mode available and huge variability in size histograms
#FL_YFT = FL_YFT[!(FLEET_CODE == "IRN" & FISHERY_GROUP_CODE == "PS")]
# 2- Remove EUREY and EUMYT HATR fisheries: mix of handlines and trolling lines?
#FL_YFT = FL_YFT[!(FLEET_CODE %in% c("EUREU", "EUMYT") & GEAR_CODE == "HATR")]
# SPATIAL RESOLUTION EQUAL OR LESS THAN 5x5 ####
# Filter resolution
FL_YFT_REGULAR_GRIDS = FL_YFT[AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05")]
# # Map to Indian Ocean 1x1 grids to filter for grids outside Indian Ocean
IO_1x1_GRID_LIST = query(DB_IOTC_MASTER(), "SELECT DISTINCT CODE, NAME_EN FROM refs_gis.V_IO_GRIDS_01x01;")
#
GRIDS_1x1_NOT_IN_IO = unique(merge(FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01"], IO_1x1_GRID_LIST, by.x = "FISHING_GROUND_CODE", by.y = "CODE", all.x = TRUE)[is.na(NAME_EN), .(FISHING_GROUND_CODE)])[order(FISHING_GROUND_CODE)]
GRIDS_1x1_NOT_IN_IO[, CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Remove these grids from the dataset prior to conversion
FL_YFT_REGULAR_GRIDS = FL_YFT_REGULAR_GRIDS[!FISHING_GROUND_CODE %in% GRIDS_1x1_NOT_IN_IO$FISHING_GROUND_CODE]
# Create original file for combination with irregular grid dataset
FL_YFT_REGULAR_GRIDS_ORIGINAL = FL_YFT_REGULAR_GRIDS[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
# Convert 1x1 to 5x5
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01", CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Keep 5x5 grids
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID05x05", CWP55 := FISHING_GROUND_CODE]
# Re-aggregate by 5x5 grids
FL_YFT_REGULAR_TO_CWP55 = FL_YFT_REGULAR_GRIDS[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE = CWP55, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
# DATASET WITH SPATIAL RESOLUTION LARGER THAN 5x5 SPATIAL RESOLUTION ####
# Extract area codes from dataset
LIST_NON_STANDARD_AREAS = FL_YFT[!AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05"), .(N_SAMPLES = sum(FISH_COUNT)), keyby = .(FISHING_GROUND_CODE, RAISE_CODE)][order(-N_SAMPLES)]
# Potential filter the list on non-standard areas
# Large areas of areas with too small samples (<50)
LIST_AREAS_TO_REMOVE = c("IO_EAST", "IO_NORTHEAST", "IO_NORTHWEST", "IO_SOUTHEAST", "IO_WEST", "IO_SOUTHWEST", "A230120", "A240140", "A240040")
# Summary of data removed
FL_YFT_IRREGULAR_GRIDS_REMOVED = FL_YFT[FISHING_GROUND_CODE %in% LIST_AREAS_TO_REMOVE, .(N_SAMPLES = sum(FISH_COUNT)), keyby = .(FISHING_GROUND_CODE, RAISE_CODE)]
LIST_NON_STANDARD_AREAS_FILTERED = LIST_NON_STANDARD_AREAS[!FISHING_GROUND_CODE %in% LIST_AREAS_TO_REMOVE]
# Extract mapping between irregular areas and 5x5 grids
MAPPING_NON_STANDARD_AREAS_TO_5x5 =
query(
C_MASTER,
paste0("SELECT SOURCE_CODE AS FISHING_GROUND_CODE, TARGET_CODE AS CWP55, SOURCE_REL_INTERSECTION
FROM refs_gis.AREA_INTERSECTIONS
WHERE SOURCE_CODE IN ('", paste(LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE, collapse = "', '"), "')
AND SUBSTRING(TARGET_CODE, 1, 1) = '6';"))
# Add number of 5x5 grids per irregular area
MAPPING_NON_STANDARD_AREAS_TO_5x5[, N_GRIDS := length(unique(CWP55)), keyby = .(FISHING_GROUND_CODE)]
MAPPING_NON_STANDARD_AREAS_TO_5x5[, PROP_GRIDS := 1/N_GRIDS]
# Map size dataset with 5x5 grids
FL_YFT_IRREGULAR_GRIDS = FL_YFT[FISHING_GROUND_CODE %in% LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID = merge.data.table(FL_YFT_IRREGULAR_GRIDS, MAPPING_NON_STANDARD_AREAS_TO_5x5, by.x = "FISHING_GROUND_CODE", by.y = "FISHING_GROUND_CODE", all.x = TRUE, allow.cartesian = TRUE)
# Distribute fish according to surface area
#FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, FISH_ALLOCATED := FISH_COUNT * SOURCE_REL_INTERSECTION, by = .(FISHING_GROUND_CODE)][, FISH_COUNT := NULL]
# Distribute fish evenly according to number of grids
FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, FISH_ALLOCATED := FISH_COUNT * PROP_GRIDS, by = .(FISHING_GROUND_CODE)][, FISH_COUNT := NULL]
# Rename FISH COUNT column
setnames(FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID, old = "FISH_ALLOCATED", new = "FISH_COUNT")
# Re-aggregate by 5x5 grids
FL_YFT_IRREGULAR_TO_CWP55 = FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE = CWP55, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
# BUILD UNIFIED DATASETS
## ORIGINAL GRID DATASET ####
FL_YFT_ORIGINAL_GRIDS = rbindlist(list(FL_YFT_REGULAR_GRIDS_ORIGINAL, FL_YFT_IRREGULAR_GRIDS), use.names = TRUE)
## 5x5 GRID DATASET
FL_YFT_GRIDS_TO_CWP55 = rbindlist(list(FL_YFT_REGULAR_TO_CWP55, FL_YFT_IRREGULAR_TO_CWP55))
# Aggregate across 5x5 grids
FL_YFT_GRIDS_TO_CWP55 = FL_YFT_GRIDS_TO_CWP55[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
# Export the datasets
write.csv(FL_YFT_ORIGINAL_GRIDS, paste0("../outputs/datasets/", DATASET_NAME, " (original).csv"), row.names = FALSE)
write.csv(FL_YFT_GRIDS_TO_CWP55, paste0("../outputs/datasets/", DATASET_NAME, " (cwp55).csv"), row.names = FALSE)
FL_YFT_SYC_FLL = FL_YFT_GRIDS_TO_CWP55[FLEET_CODE == "SYC" & GEAR_CODE == "ELL", .(N = sum(FISH_COUNT)), keyby = .(YEAR, CLASS_LOW, CLASS_HIGH)]
FL_YFT_SYC_FLL[, CLASS_MID := (CLASS_LOW + CLASS_HIGH)/2]
ggplot(FL_YFT_SYC_FLL, aes(x = CLASS_MID, y = N)) +
geom_line(linewidth = 1) +
xlab("Fork length (cm)") + ylab("Samples") +
theme(axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
axis.title.y = element_text(size=10),
strip.text.x = element_text(size = 10),
plot.margin = margin(.2, .3, .1, 0, "cm"),
legend.position = "none",
legend.title = element_blank()) +
#coord_cartesian(xlim = c(50, 200)) +
theme(strip.background = element_rect(fill = "white")) +
facet_wrap(~YEAR, scales = "free_y")
# FILTER THE DATASET ####
FL_YFT = copy(SF_STD_YFT)
## Iranian purse seiners ####
# No fishing mode available and huge variability in size histograms
#FL_YFT = FL_YFT[!(FLEET_CODE == "IRN" & FISHERY_GROUP_CODE == "PS")]
# 2- Remove EUREY and EUMYT HATR fisheries: mix of handlines and trolling lines?
#FL_YFT = FL_YFT[!(FLEET_CODE %in% c("EUREU", "EUMYT") & GEAR_CODE == "HATR")]
# SPATIAL RESOLUTION EQUAL OR LESS THAN 5x5 ####
# Filter resolution
FL_YFT_REGULAR_GRIDS = FL_YFT[AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05")]
# # Map to Indian Ocean 1x1 grids to filter for grids outside Indian Ocean
IO_1x1_GRID_LIST = query(DB_IOTC_MASTER(), "SELECT DISTINCT CODE, NAME_EN FROM refs_gis.V_IO_GRIDS_01x01;")
#
GRIDS_1x1_NOT_IN_IO = unique(merge(FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01"], IO_1x1_GRID_LIST, by.x = "FISHING_GROUND_CODE", by.y = "CODE", all.x = TRUE)[is.na(NAME_EN), .(FISHING_GROUND_CODE)])[order(FISHING_GROUND_CODE)]
GRIDS_1x1_NOT_IN_IO[, CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Remove these grids from the dataset prior to conversion
FL_YFT_REGULAR_GRIDS = FL_YFT_REGULAR_GRIDS[!FISHING_GROUND_CODE %in% GRIDS_1x1_NOT_IN_IO$FISHING_GROUND_CODE]
# Create original file for combination with irregular grid dataset
FL_YFT_REGULAR_GRIDS_ORIGINAL = FL_YFT_REGULAR_GRIDS[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
# Convert 1x1 to 5x5
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID01x01", CWP55 := convert_CWP_grid(FISHING_GROUND_CODE, grid_5x5), by = .(FISHING_GROUND_CODE)]
# Keep 5x5 grids
FL_YFT_REGULAR_GRIDS[AREA_TYPE_CODE == "GRID05x05", CWP55 := FISHING_GROUND_CODE]
# Re-aggregate by 5x5 grids
FL_YFT_REGULAR_TO_CWP55 = FL_YFT_REGULAR_GRIDS[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE = CWP55, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
# DATASET WITH SPATIAL RESOLUTION LARGER THAN 5x5 SPATIAL RESOLUTION ####
# Extract area codes from dataset
LIST_NON_STANDARD_AREAS = FL_YFT[!AREA_TYPE_CODE %in% c("GRID01x01", "GRID05x05"), .(N_SAMPLES = sum(FISH_COUNT)), keyby = .(FISHING_GROUND_CODE, RAISE_CODE)][order(-N_SAMPLES)]
# Potential filter the list on non-standard areas
# Large areas of areas with too small samples (<50)
LIST_AREAS_TO_REMOVE = c("IO_EAST", "IO_NORTHEAST", "IO_NORTHWEST", "IO_SOUTHEAST", "IO_WEST", "IO_SOUTHWEST", "A230120", "A240140", "A240040")
# Summary of data removed
FL_YFT_IRREGULAR_GRIDS_REMOVED = FL_YFT[FISHING_GROUND_CODE %in% LIST_AREAS_TO_REMOVE, .(N_SAMPLES = sum(FISH_COUNT)), keyby = .(FISHING_GROUND_CODE, RAISE_CODE)]
LIST_NON_STANDARD_AREAS_FILTERED = LIST_NON_STANDARD_AREAS[!FISHING_GROUND_CODE %in% LIST_AREAS_TO_REMOVE]
# Extract mapping between irregular areas and 5x5 grids
MAPPING_NON_STANDARD_AREAS_TO_5x5 =
query(
C_MASTER,
paste0("SELECT SOURCE_CODE AS FISHING_GROUND_CODE, TARGET_CODE AS CWP55, SOURCE_REL_INTERSECTION
FROM refs_gis.AREA_INTERSECTIONS
WHERE SOURCE_CODE IN ('", paste(LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE, collapse = "', '"), "')
AND SUBSTRING(TARGET_CODE, 1, 1) = '6';"))
# Add number of 5x5 grids per irregular area
MAPPING_NON_STANDARD_AREAS_TO_5x5[, N_GRIDS := length(unique(CWP55)), keyby = .(FISHING_GROUND_CODE)]
MAPPING_NON_STANDARD_AREAS_TO_5x5[, PROP_GRIDS := 1/N_GRIDS]
# Map size dataset with 5x5 grids
FL_YFT_IRREGULAR_GRIDS = FL_YFT[FISHING_GROUND_CODE %in% LIST_NON_STANDARD_AREAS_FILTERED$FISHING_GROUND_CODE, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID = merge.data.table(FL_YFT_IRREGULAR_GRIDS, MAPPING_NON_STANDARD_AREAS_TO_5x5, by.x = "FISHING_GROUND_CODE", by.y = "FISHING_GROUND_CODE", all.x = TRUE, allow.cartesian = TRUE)
# Distribute fish according to surface area
#FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, FISH_ALLOCATED := FISH_COUNT * SOURCE_REL_INTERSECTION, by = .(FISHING_GROUND_CODE)][, FISH_COUNT := NULL]
# Distribute fish evenly according to number of grids
FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, FISH_ALLOCATED := FISH_COUNT * PROP_GRIDS, by = .(FISHING_GROUND_CODE)][, FISH_COUNT := NULL]
# Rename FISH COUNT column
setnames(FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID, old = "FISH_ALLOCATED", new = "FISH_COUNT")
# Re-aggregate by 5x5 grids
FL_YFT_IRREGULAR_TO_CWP55 = FL_YFT_IRREGULAR_GRIDS_MAPPED_CWP55_GRID[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE = CWP55, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
# BUILD UNIFIED DATASETS
## ORIGINAL GRID DATASET ####
FL_YFT_ORIGINAL_GRIDS = rbindlist(list(FL_YFT_REGULAR_GRIDS_ORIGINAL, FL_YFT_IRREGULAR_GRIDS), use.names = TRUE)
## 5x5 GRID DATASET
FL_YFT_GRIDS_TO_CWP55 = rbindlist(list(FL_YFT_REGULAR_TO_CWP55, FL_YFT_IRREGULAR_TO_CWP55))
# Aggregate across 5x5 grids
FL_YFT_GRIDS_TO_CWP55 = FL_YFT_GRIDS_TO_CWP55[, .(FISH_COUNT = sum(FISH_COUNT)), keyby = .(YEAR, MONTH_START, MONTH_END, FLEET_CODE, GEAR_CODE, FISHERY_GROUP_CODE, FISHERY_TYPE_CODE, SCHOOL_TYPE_CODE, FISHERY_CODE, FISHING_GROUND_CODE, SPECIES_CODE, MEASURE_TYPE_CODE, CLASS_LOW, CLASS_HIGH, RAISE_CODE, REPORTING_QUALITY)]
# Export the datasets
write.csv(FL_YFT_ORIGINAL_GRIDS, paste0("../outputs/datasets/", DATASET_NAME, " (original).csv"), row.names = FALSE)
write.csv(FL_YFT_GRIDS_TO_CWP55, paste0("../outputs/datasets/", DATASET_NAME, " (cwp55).csv"), row.names = FALSE)
sum(FL_YFT_ORIGINAL_GRIDS$FISH_COUNT)
sum(FL_YFT_GRIDS_TO_CWP55$FISH_COUNT)
library(iotc.base.common.std)
iotc.base.common.std::DEFAULT_IOTC_LL_EQUATIONS
iotc.base.common.std::DEFAULT_IOTC_LL_EQUATIONS[SPECIES == "YFT"]
?DEFAULT_IOTC_LL_EQUATIONS
?convert_lengths
convert_lengths("YFT", "LDF", "FL", 100)
convert_lengths("YFT", "LDF", "FL", 30)
SF_RAW_YFT[SPECIES_CODE == "YFT", .N, .(MEASURE_TYPE_CODE, MEASURE_TYPE)]
SF_RAW_YFT[SPECIES_CODE == "YFT", .N, keyby = .(MEASURE_TYPE_CODE, MEASURE_TYPE)]
convert_lengths("YFT", "LDF", "FL", 30)
convert_lengths("YFT", "DF", "FL", 30)
convert_lengths("YFT", "PAL", "FL", 30)
standardize_size_frequencies
1/0.6215
library(devtools)
options(download.file.method = "libcurl")
install_bitbucket("iotc-ws/base-common-std",          dependencies = TRUE)
library(iotc.base.common.std)
convert_lengths("YFT", "PCL", "FL", measurement = 100)
library(devtools)
options(download.file.method = "libcurl")
install_bitbucket("iotc-ws/base-common-std",          dependencies = TRUE)
